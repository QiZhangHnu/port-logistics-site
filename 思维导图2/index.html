<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>港口物流知识图谱</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        * { box-sizing: border-box; }

        html, body, #chart {
            width: 100%;
            height: 100%;
            margin: 0;
        }

        body {
            background:
                radial-gradient(circle at 10px 10px, #e7ebf5 1px, transparent 1px),
                #f4f6fb;
            background-size: 26px 26px;
            font-family: "Noto Sans SC", "Segoe UI", "Helvetica Neue", Arial, sans-serif;
            color: #1f2937;
        }

        .node circle {
            fill: #fff;
            stroke-width: 1.8px;
            cursor: pointer;
            transition: transform 0.2s ease, stroke-width 0.2s ease;
        }

        .node circle:hover {
            stroke-width: 2.4px;
            transform: scale(1.08);
        }

        .node.root circle {
            r: 12;
            fill: #273c9c;
            stroke: #273c9c;
        }

        .node text {
            font-size: 13px;
            letter-spacing: 0.1px;
            fill: #000;
            pointer-events: none;
        }

        .node.root text {
            font-weight: 700;
            font-size: 20px;
            fill: #000;
            text-shadow: none;
        }

        .link {
            fill: none;
            stroke-width: 1.6px;
            stroke-linecap: round;
            opacity: 0.9;
        }

        .page-title {
            position: fixed;
            top: 28px;
            left: 32px;
            font-family: "LiSu", "STLiti", "Noto Serif SC", "KaiTi", serif;
            font-size: 42px;
            font-weight: 700;
            color: #000;
            pointer-events: none;
            z-index: 10;
        }

        .controls {
            position: fixed;
            right: 20px;
            bottom: 20px;
            display: flex;
            gap: 10px;
            z-index: 20;
        }

        .controls button {
            padding: 10px 14px;
            border: 1px solid #273c9c;
            background: #fff;
            color: #273c9c;
            border-radius: 10px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            box-shadow: 0 6px 16px rgba(39, 60, 156, 0.14);
            transition: transform 0.15s ease, box-shadow 0.15s ease, background 0.15s ease;
        }

        .controls button:hover {
            background: #273c9c;
            color: #fff;
            transform: translateY(-1px);
            box-shadow: 0 10px 20px rgba(39, 60, 156, 0.18);
        }
    </style>
</head>
<body>
    <div class="page-title">《港口物流》课程知识图谱</div>
    <div class="controls">
        <button id="expand-depth-3" type="button">展开第3层</button>
        <button id="expand-depth-4" type="button">展开第4层</button>
    </div>
    <div id="chart"></div>

    <script>
        // Fallback sample for debugging when result.json cannot be loaded
        const mockData = {
            name: "示例数据",
            children: [
                {
                    name: "一级节点A",
                    children: [
                        { name: "二级 A-1" },
                        { name: "二级 A-2" },
                        { name: "二级 A-3" }
                    ]
                },
                {
                    name: "一级节点B",
                    children: [
                        { name: "二级 B-1" },
                        { name: "二级 B-2" }
                    ]
                },
                {
                    name: "一级节点C",
                    children: [
                        { name: "二级 C-1" },
                        { name: "二级 C-2" },
                        { name: "二级 C-3" },
                        { name: "二级 C-4" }
                    ]
                }
            ]
        };

        const width = window.innerWidth;
        const height = window.innerHeight;
        const radius = Math.min(width, height) / 2 - 80;

        const svg = d3.select("#chart")
            .append("svg")
            .attr("width", width)
            .attr("height", height)
            .attr("viewBox", [-width / 2, -height / 2, width, height])
            .style("font", "12px sans-serif")
            .style("user-select", "none");

        const g = svg.append("g");

        let rootLabelVisible = true;
        function setRootLabelVisibility(show) {
            const rootText = g.select("g.node.root text");
            if (!rootText.empty()) {
                rootText.transition().duration(200).attr("opacity", show ? 1 : 0);
            }
            rootLabelVisible = show;
        }

        const zoom = d3.zoom()
            .scaleExtent([0.2, 4])
            .on("zoom", (event) => g.attr("transform", event.transform));

        svg.call(zoom);
        svg.call(zoom.transform, d3.zoomIdentity);

        const tree = d3.tree()
            .size([2 * Math.PI, radius])
            .separation((a, b) => (a.parent === b.parent ? 1 : 2) / a.depth);

        const diagonal = d3.linkRadial()
            .angle(d => d.x)
            .radius(d => d.y);

        const palette = [
            "#273c9c", "#3682f4", "#37b2c5", "#2fa36b", "#5bc25b",
            "#ffb347", "#ef6c64", "#cc4c9c", "#8a64d6", "#5f7cff"
        ];
        const color = d3.scaleOrdinal(palette);

        function linkTint(name) {
            const c = d3.color(color(name));
            if (!c) return "#cbd5e1";
            c.opacity = 0.4;
            return c.formatRgb();
        }

        function normalize(node) {
            if (!node) return null;
            const children = Array.isArray(node.children)
                ? node.children.map(normalize).filter(Boolean)
                : [];
            return {
                name: node.title || node.name || node.id || "未命名节点",
                children
            };
        }

        function getMaxDepth(node, depth = 0) {
            if (!node || !node.children || node.children.length === 0) return depth;
            return Math.max(...node.children.map(child => getMaxDepth(child, depth + 1)));
        }

        function getAncestorName(node) {
            let current = node;
            while (current.parent && current.parent.parent) {
                current = current.parent;
            }
            return current.data.name;
        }

        function drawChart(data) {
            const root = d3.hierarchy(data);
            root.descendants().forEach((d, i) => {
                d.id = i;
                d._children = d.children;
                if (d.depth > 1 && d._children) {
                    d.children = null; // Start collapsed for deep nodes
                }
            });

            root.x0 = 0;
            root.y0 = 0;

            update(root);

            function setExpandDepth(targetDepth) {
                root.eachBefore(d => {
                    if (d.depth < targetDepth) {
                        if (d._children) {
                            d.children = d._children;
                            d._children = null;
                        }
                    } else if (d.depth >= targetDepth) {
                        if (d.children) {
                            d._children = d.children;
                            d.children = null;
                        }
                    }
                });
                update(root);
            }

            function update(source) {
                tree(root);

                const nodes = root.descendants();
                const links = root.links();

                const node = g.selectAll("g.node")
                    .data(nodes, d => d.id);

                const nodeEnter = node.enter().append("g")
                    .attr("class", d => d.depth === 0 ? "node root" : "node")
                    .attr("transform", d => d.depth === 0
                        ? "translate(0,0)"
                        : `rotate(${source.x0 * 180 / Math.PI - 90}) translate(${source.y0},0)`)
                    .on("click", (event, d) => {
                        if (d.depth === 0) return;
                        setRootLabelVisibility(d.depth < 2);
                        d.children = d.children ? null : d._children;
                        update(d);
                    });

                nodeEnter.append("circle")
                    .attr("r", 1e-6)
                    .attr("fill", d => d.depth === 0 ? "#273c9c" : (d._children ? color(getAncestorName(d)) : "#fff"))
                    .attr("stroke", d => color(getAncestorName(d)));

                nodeEnter.append("text")
                    .attr("dy", d => d.depth === 0 ? "-2.0em" : "0.32em")
                    .attr("x", d => d.depth === 0 ? 0 : (d.x < Math.PI === !d.children ? 12 : -12))
                    .attr("text-anchor", d => d.depth === 0 ? "middle" : (d.x < Math.PI === !d.children ? "start" : "end"))
                    .attr("transform", d => d.depth === 0 ? null : (d.x >= Math.PI ? "rotate(180)" : null))
                    .text(d => d.data.name)
                    .attr("opacity", 1e-6);

                const nodeUpdate = node.merge(nodeEnter).transition()
                    .duration(400)
                    .attr("transform", d => d.depth === 0
                        ? "translate(0,0)"
                        : `rotate(${d.x * 180 / Math.PI - 90}) translate(${d.y},0)`);

                nodeUpdate.select("circle")
                    .attr("r", d => d.depth === 0 ? 14 : 6)
                    .attr("fill", d => d.depth === 0 ? "#273c9c" : (d._children ? color(getAncestorName(d)) : "#fff"))
                    .attr("stroke", d => color(getAncestorName(d)));

                nodeUpdate.select("text")
                    .attr("opacity", 1)
                    .attr("font-weight", d => d.depth === 0 ? 700 : 500)
                    .attr("font-size", d => d.depth === 0 ? 20 : 13)
                    .attr("dy", d => d.depth === 0 ? "-0.4em" : "0.32em")
                    .attr("x", d => d.depth === 0 ? 0 : (d.x < Math.PI === !d.children ? 12 : -12))
                    .attr("text-anchor", d => d.depth === 0 ? "middle" : (d.x < Math.PI === !d.children ? "start" : "end"))
                    .attr("transform", d => d.depth === 0 ? null : (d.x >= Math.PI ? "rotate(180)" : null));

                const nodeExit = node.exit().transition()
                    .duration(400)
                    .attr("transform", d => `rotate(${source.x * 180 / Math.PI - 90}) translate(${source.y},0)`)
                    .remove();

                nodeExit.select("circle").attr("r", 1e-6);
                nodeExit.select("text").attr("opacity", 1e-6);

                const link = g.selectAll("path.link")
                    .data(links, d => d.target.id);

                const linkEnter = link.enter().insert("path", "g")
                    .attr("class", "link")
                    .attr("d", () => {
                        const o = { x: source.x0, y: source.y0 };
                        return diagonal({ source: o, target: o });
                    })
                    .attr("stroke", d => linkTint(getAncestorName(d.target)));

                link.merge(linkEnter).transition()
                    .duration(400)
                    .attr("d", diagonal)
                    .attr("stroke", d => linkTint(getAncestorName(d.target)));

                link.exit().transition()
                    .duration(400)
                    .attr("d", () => {
                        const o = { x: source.x, y: source.y };
                        return diagonal({ source: o, target: o });
                    })
                    .remove();

                nodes.forEach(d => {
                    d.x0 = d.x;
                    d.y0 = d.y;
                });

                setRootLabelVisibility(rootLabelVisible);
            }

            return { expandTo: setExpandDepth };
        }

        let chartControl = null;
        let dataMaxDepth = 0;
        let maxLayerCount = 0;

        async function init() {
            try {
                const raw = await d3.json("result.json");
                const rootSource = Array.isArray(raw) ? raw[0] : raw;
                if (!rootSource) {
                    throw new Error("result.json is empty");
                }
                dataMaxDepth = getMaxDepth(rootSource);
                maxLayerCount = dataMaxDepth + 1;
                const normalized = normalize(rootSource);
                chartControl = drawChart(normalized);
                if (btnExpand4 && maxLayerCount < 4) {
                    btnExpand4.textContent = `展开至最深层（共${maxLayerCount}层）`;
                }
                console.log("已从 result.json 加载知识图谱数据");
            } catch (err) {
                console.warn("读取 result.json 失败，使用示例数据", err);
                dataMaxDepth = getMaxDepth(mockData);
                maxLayerCount = dataMaxDepth + 1;
                chartControl = drawChart(mockData);
            }
        }

        const btnExpand3 = document.getElementById("expand-depth-3");
        const btnExpand4 = document.getElementById("expand-depth-4");

        init();

        const expandToDepth = depth => {
            const maxSelectable = maxLayerCount || depth;
            const target = Math.min(depth, maxSelectable);
            if (chartControl) {
                chartControl.expandTo(target);
            }
            // Hide center label once第3层及更深展开，恢复在较浅层
            setRootLabelVisibility(target < 3);
            if (maxSelectable && depth > maxSelectable) {
                console.info(`数据最深为 ${maxSelectable} 层，已展开至最深层`);
            }
        };

        btnExpand3.addEventListener("click", () => expandToDepth(3));
        btnExpand4.addEventListener("click", () => expandToDepth(4));

        window.addEventListener("resize", () => location.reload());
    </script>
</body>
</html>
